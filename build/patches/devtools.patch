From: TwoLeaves <ohneherren@gmail.com>
Date: Sat, 7 Feb 2026 12:00:00 +0000
Subject: Add Developer Tools on Android

Add a Developer Tools option to the toolbar menu on Android.

---
diff --git a/chrome/android/java/res/values/ids.xml b/chrome/android/java/res/values/ids.xml
index 170ae05ab797e9..cdb4bf348e54e6 100644
--- a/chrome/android/java/res/values/ids.xml
+++ b/chrome/android/java/res/values/ids.xml
@@ -108,6 +108,7 @@ found in the LICENSE file.
     <!-- Video Group -->
     <item type="id" name="contextmenu_save_video" />
     <item type="id" name="contextmenu_picture_in_picture" />
+    <item type="id" name="contextmenu_extensions_menu" />
 
     <!-- Menu item IDs for FullscreenActivities -->
     <item type="id" name="contextmenu_open_in_chrome" />
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java b/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java
index 2fa43ec87b84fc..ef5b83b9e458c2 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java
@@ -440,9 +440,9 @@ boolean shouldShowEmptySpaceContextMenu() {
     @VisibleForTesting
     boolean shouldShowDeveloperMenu() {
         return DevToolsWindowAndroid.isDevToolsAllowedFor(
-                        getProfile(), mItemDelegate.getWebContents())
-                && DeviceInput.supportsAlphabeticKeyboard()
-                && DeviceInput.supportsPrecisionPointer();
+                        getProfile(), mItemDelegate.getWebContents());
+                // && DeviceInput.supportsAlphabeticKeyboard()
+                // && DeviceInput.supportsPrecisionPointer();
     }
 
     @VisibleForTesting
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
index ddf601af83b591..b50fa1f5c54afa 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
@@ -11,6 +11,7 @@
 import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Context;
+import android.graphics.Rect;
 import android.net.Uri;
 import android.os.Build;
 import android.os.SystemClock;
@@ -686,6 +687,7 @@ public boolean isShowingErrorPage() {
      * @return true iff the tab doesn't hold a live page. This happens before initialize() and when
      *     the tab holds frozen WebContents state that is yet to be inflated.
      */
+    @CalledByNative
     @Override
     public boolean isFrozen() {
         return !isNativePage() && getWebContents() == null;
@@ -1122,11 +1124,19 @@ public void stopLoading() {
         if (getWebContents() != null) getWebContents().stop();
     }
 
+    @CalledByNative
     @Override
     public boolean needsReload() {
         return getWebContents() != null && getWebContents().getNavigationController().needsReload();
     }
 
+    @CalledByNative
+    @Override
+    public Rect getBounds() {
+        if (getWindowAndroid() == null) return new Rect();
+        return getWindowAndroid().getDisplay().getBounds();
+    }
+
     @Override
     public boolean isLoading() {
         return mIsLoading;
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedAppMenuPropertiesDelegate.java b/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedAppMenuPropertiesDelegate.java
index 6d8ef314c1f13d..879be36109525b 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedAppMenuPropertiesDelegate.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedAppMenuPropertiesDelegate.java
@@ -304,6 +304,8 @@ private void populatePageModeMenu(MVCListAdapter.ModelList modelList) {
             }
         }
 
+        modelList.add(buildDevToolsItem());
+
         // Divider
         modelList.add(
                 new MVCListAdapter.ListItem(
@@ -726,6 +728,15 @@ private MVCListAdapter.ListItem buildChromeWebstoreItem() {
                                 : Resources.ID_NULL));
     }
 
+    private MVCListAdapter.ListItem buildDevToolsItem() {
+        return new MVCListAdapter.ListItem(
+                AppMenuHandler.AppMenuItemType.STANDARD,
+                buildModelForStandardMenuItem(
+                        R.id.dev_tools,
+                        R.string.menu_dev_tools,
+                        shouldShowIconBeforeItem() ? R.drawable.ic_dev_tools_24dp : 0));
+    }
+
     @Contract("null -> false")
     private boolean shouldShowPageZoomItem(@Nullable Tab currentTab) {
         return currentTab != null
@@ -733,6 +744,7 @@ && shouldShowWebContentsDependentMenuItem(currentTab)
                 && PageZoomUtils.shouldShowZoomMenuItem();
     }
 
+
     private boolean shouldShowLFFPageZoomItem() {
         return AccessibilityFeatureMap.sAndroidZoomIndicator.isEnabled()
                 && DeviceFormFactor.isNonMultiDisplayContextOnTablet(mContext);
diff --git a/chrome/browser/android/tab_android.cc b/chrome/browser/android/tab_android.cc
index 23b0f8bcbb2075..1b66b4ed2293f2 100644
--- a/chrome/browser/android/tab_android.cc
+++ b/chrome/browser/android/tab_android.cc
@@ -218,6 +218,14 @@ std::unique_ptr<TabAndroid> TabAndroid::CreateForTesting(
   return tab;
 }
 
+SessionID TabAndroid::GetTabId() const {
+  auto* contents = web_contents();
+  if (contents) {
+    return sessions::SessionTabHelper::IdForTab(contents);
+  }
+  return SessionID::InvalidValue();
+}
+
 SessionID TabAndroid::GetWindowId() const {
   return session_window_id_;
 }
@@ -288,6 +296,38 @@ bool TabAndroid::IsUserInteractable() const {
   return Java_TabImpl_isUserInteractable(env, weak_java_tab_.get(env));
 }
 
+bool TabAndroid::IsFrozen() const {
+  JNIEnv* env = base::android::AttachCurrentThread();
+  return Java_TabImpl_isFrozen(env, weak_java_tab_.get(env));
+}
+
+bool TabAndroid::NeedsReload() const {
+  JNIEnv* env = base::android::AttachCurrentThread();
+  return Java_TabImpl_needsReload(env, weak_java_tab_.get(env));
+}
+
+gfx::Rect TabAndroid::GetBounds() const {
+  JNIEnv* env = base::android::AttachCurrentThread();
+  // it would be much better to move all this gni magic
+  // somewhere else, like base::Android::something
+  base::android::ScopedJavaLocalRef<jobject> j_rect = Java_TabImpl_getBounds(env, weak_java_tab_.get(env));
+  jclass cls = env->GetObjectClass(j_rect.obj());
+
+  jfieldID left_field = env->GetFieldID(cls, "left", "I");
+  const int left = env->GetIntField(j_rect.obj(), left_field);
+
+  jfieldID top_field = env->GetFieldID(cls, "top", "I");
+  const int top = env->GetIntField(j_rect.obj(), top_field);
+
+  jfieldID right_field = env->GetFieldID(cls, "right", "I");
+  const int right = env->GetIntField(j_rect.obj(), right_field);
+
+  jfieldID bottom_field = env->GetFieldID(cls, "bottom", "I");
+  const int bottom = env->GetIntField(j_rect.obj(), bottom_field);
+
+  return gfx::Rect(top, left, right - left, bottom - top);
+}
+
 sync_sessions::SyncedTabDelegate* TabAndroid::GetSyncedTabDelegate() const {
   return synced_tab_delegate_.get();
 }
@@ -321,6 +361,11 @@ int TabAndroid::GetParentId() const {
   return Java_TabImpl_getParentId(env, weak_java_tab_.get(env));
 }
 
+std::optional<base::Token> TabAndroid::GetTabGroupId() const {
+  JNIEnv* env = base::android::AttachCurrentThread();
+  return Java_TabImpl_getTabGroupId(env, weak_java_tab_.get(env));
+}
+
 void TabAndroid::DeleteFrozenNavigationEntries(
     const WebContentsState::DeletionPredicate& predicate) {
   JNIEnv* env = base::android::AttachCurrentThread();
diff --git a/chrome/browser/android/tab_android.h b/chrome/browser/android/tab_android.h
index 23ef3d9531e9a3..54b796cac27ec3 100644
--- a/chrome/browser/android/tab_android.h
+++ b/chrome/browser/android/tab_android.h
@@ -99,6 +99,7 @@ class TabAndroid : public tabs::TabInterface,
       int tab_id,
       std::unique_ptr<content::WebContents> web_contents);
 
+  SessionID GetTabId() const;
   // TabAndroidDataProvider
   SessionID GetWindowId() const override;
   int GetAndroidId() const override;
@@ -134,6 +135,9 @@ class TabAndroid : public tabs::TabInterface,
   // Return whether the tab is currently visible and the user can interact with
   // it.
   bool IsUserInteractable() const;
+  bool IsFrozen() const;
+  bool NeedsReload() const;
+  gfx::Rect GetBounds() const;
 
   sync_sessions::SyncedTabDelegate* GetSyncedTabDelegate() const;
 
@@ -152,6 +156,9 @@ class TabAndroid : public tabs::TabInterface,
   // Returns the parent tab identifier for the tab.
   int GetParentId() const;
 
+  // Returns the tab group ID of the Tab or null if not part of a group.
+  std::optional<base::Token> GetTabGroupId() const;
+
   // Delete navigation entries matching predicate from frozen state.
   void DeleteFrozenNavigationEntries(
       const WebContentsState::DeletionPredicate& predicate);
diff --git a/chrome/browser/devtools/android/java/src/org/chromium/chrome/browser/devtools/DevToolsWindowAndroid.java b/chrome/browser/devtools/android/java/src/org/chromium/chrome/browser/devtools/DevToolsWindowAndroid.java
index 27ea1dd761df37..e526bc1dc28aa5 100644
--- a/chrome/browser/devtools/android/java/src/org/chromium/chrome/browser/devtools/DevToolsWindowAndroid.java
+++ b/chrome/browser/devtools/android/java/src/org/chromium/chrome/browser/devtools/DevToolsWindowAndroid.java
@@ -20,8 +20,9 @@ public class DevToolsWindowAndroid {
     private DevToolsWindowAndroid() {}
 
     public static boolean isDevToolsAllowedFor(Profile profile, WebContents webContents) {
-        return ContentFeatureMap.isEnabled(ContentFeatureList.ANDROID_DEV_TOOLS_FRONTEND)
-                && DevToolsWindowAndroidJni.get().isDevToolsAllowedFor(profile, webContents);
+        // TODO dig deeper
+        return true; /* ContentFeatureMap.isEnabled(ContentFeatureList.ANDROID_DEV_TOOLS_FRONTEND)
+                && DevToolsWindowAndroidJni.get().isDevToolsAllowedFor(profile, webContents); */
     }
 
     public static boolean canViewSource(Profile profile, WebContents webContents) {
diff --git a/chrome/browser/devtools/devtools_ui_bindings.cc b/chrome/browser/devtools/devtools_ui_bindings.cc
index 0042bfcbfb8b34..06146ec4d578f6 100644
--- a/chrome/browser/devtools/devtools_ui_bindings.cc
+++ b/chrome/browser/devtools/devtools_ui_bindings.cc
@@ -133,7 +133,7 @@
 #include "chrome/browser/user_education/user_education_service_factory.h"
 #endif
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if BUILDFLAG(ENABLE_EXTENSIONS_CORE)
 #include "chrome/browser/extensions/extension_management.h"
 #include "extensions/browser/extension_registry.h"
 #include "extensions/browser/extension_system.h"
@@ -1557,18 +1557,18 @@ void DevToolsUIBindings::SendPortForwardingStatus(base::Value status) {
 }
 
 void DevToolsUIBindings::SetDevicesUpdatesEnabled(bool enabled) {
-#if BUILDFLAG(IS_ANDROID)
-  NOTIMPLEMENTED();
-#else
+// #if BUILDFLAG(IS_ANDROID)
+//   NOTIMPLEMENTED();
+// #else
   if (devices_updates_enabled_ == enabled) {
     return;
   }
   devices_updates_enabled_ = enabled;
   if (enabled) {
-    remote_targets_handler_ = DevToolsTargetsUIHandler::CreateForAdb(
-        base::BindRepeating(&DevToolsUIBindings::DevicesUpdated,
-                            base::Unretained(this)),
-        profile_);
+    // remote_targets_handler_ = DevToolsTargetsUIHandler::CreateForAdb(
+    //     base::BindRepeating(&DevToolsUIBindings::DevicesUpdated,
+    //                         base::Unretained(this)),
+    //     profile_);
     pref_change_registrar_.Init(profile_->GetPrefs());
     pref_change_registrar_.Add(
         prefs::kDevToolsDiscoverUsbDevicesEnabled,
@@ -1590,10 +1590,10 @@ void DevToolsUIBindings::SetDevicesUpdatesEnabled(bool enabled) {
         prefs::kDevToolsTCPDiscoveryConfig,
         base::BindRepeating(&DevToolsUIBindings::DevicesDiscoveryConfigUpdated,
                             base::Unretained(this)));
-    port_status_serializer_ = std::make_unique<PortForwardingStatusSerializer>(
-        base::BindRepeating(&DevToolsUIBindings::SendPortForwardingStatus,
-                            base::Unretained(this)),
-        profile_);
+    // port_status_serializer_ = std::make_unique<PortForwardingStatusSerializer>(
+    //     base::BindRepeating(&DevToolsUIBindings::SendPortForwardingStatus,
+    //                         base::Unretained(this)),
+    //     profile_);
     DevicesDiscoveryConfigUpdated();
   } else {
     remote_targets_handler_.reset();
@@ -1601,7 +1601,7 @@ void DevToolsUIBindings::SetDevicesUpdatesEnabled(bool enabled) {
     pref_change_registrar_.RemoveAll();
     SendPortForwardingStatus(base::Value());
   }
-#endif
+// #endif
 }
 
 void DevToolsUIBindings::OpenRemotePage(const std::string& browser_id,
@@ -2521,7 +2521,7 @@ void DevToolsUIBindings::OnPermissionDialogResult(
 }
 
 void DevToolsUIBindings::AddDevToolsExtensionsToClient() {
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if BUILDFLAG(ENABLE_EXTENSIONS_CORE)
   const extensions::ExtensionRegistry* registry =
       extensions::ExtensionRegistry::Get(profile_->GetOriginalProfile());
   if (!registry) {
diff --git a/chrome/browser/extensions/browser_extension_window_controller.cc b/chrome/browser/extensions/browser_extension_window_controller.cc
index ffdd3f3216ffb4..dc037257059a74 100644
--- a/chrome/browser/extensions/browser_extension_window_controller.cc
+++ b/chrome/browser/extensions/browser_extension_window_controller.cc
@@ -45,6 +45,11 @@
 
 static_assert(BUILDFLAG(ENABLE_EXTENSIONS_CORE));
 
+// #if BUILDFLAG(IS_ANDROID)
+// #include "chrome/browser/ui/android/tab_model/tab_model.h"
+// #include "chrome/browser/ui/android/tab_model/tab_model_list.h"
+// #endif
+
 namespace extensions {
 
 namespace {
@@ -76,10 +81,10 @@ api::tabs::WindowType GetTabsWindowType(const BrowserWindowInterface* browser) {
     case BrowserWindowInterface::TYPE_APP_POPUP:
     case BrowserWindowInterface::TYPE_POPUP:
       return api::tabs::WindowType::kPopup;
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
     case BrowserWindowInterface::TYPE_DEVTOOLS:
       return api::tabs::WindowType::kDevtools;
-#endif
+// #endif
 
     // All the following are considered "normal".
     // TODO(https://crbug.com/438514981): This is almost certainly wrong, and
@@ -87,9 +92,9 @@ api::tabs::WindowType GetTabsWindowType(const BrowserWindowInterface* browser) {
     // closer to a popup, and custom tabs might be app-like (if they can even
     // reach this point).
     case BrowserWindowInterface::TYPE_NORMAL:
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
     case BrowserWindowInterface::TYPE_PICTURE_IN_PICTURE:
-#endif
+// #endif
 #if BUILDFLAG(IS_CHROMEOS)
     case BrowserWindowInterface::TYPE_CUSTOM_TAB:
 #endif
@@ -140,7 +145,7 @@ void BrowserExtensionWindowController::SetFullscreenMode(
   NOTIMPLEMENTED();
 #else
   if (window_->IsFullscreen() != is_fullscreen) {
-    GetBrowser()->ToggleFullscreenModeWithExtension(extension_url);
+    // GetBrowser()->ToggleFullscreenModeWithExtension(extension_url);
   }
 #endif
 }
@@ -317,6 +322,10 @@ bool BrowserExtensionWindowController::OpenOptionsPage(
     const GURL& url,
     bool open_in_tab) {
   DCHECK(OptionsPageInfo::HasOptionsPage(extension));
+#if BUILDFLAG(IS_ANDROID)
+  // TODO!!!
+  return false;
+#else
 
 #if BUILDFLAG(IS_ANDROID)
   NOTIMPLEMENTED();
@@ -344,6 +353,7 @@ bool BrowserExtensionWindowController::OpenOptionsPage(
 #endif
 
   return true;
+#endif
 }
 
 bool BrowserExtensionWindowController::SupportsTabs() {
diff --git a/chrome/browser/extensions/extension_tab_util.cc b/chrome/browser/extensions/extension_tab_util.cc
index b2441f8e183c24..b9b33354e33020 100644
--- a/chrome/browser/extensions/extension_tab_util.cc
+++ b/chrome/browser/extensions/extension_tab_util.cc
@@ -65,8 +65,15 @@
 #include "url/url_constants.h"
 
 #if BUILDFLAG(IS_ANDROID)
+#include "base/types/expected_macros.h"
 #include "chrome/browser/ui/android/tab_model/tab_model.h"
 #include "chrome/browser/ui/android/tab_model/tab_model_list.h"
+#include "extensions/common/manifest_handlers/incognito_info.h"
+// #include "chrome/browser/ui/browser.h"                   // nogncheck
+#include "chrome/browser/ui/browser_finder.h"            // nogncheck
+// #include "chrome/browser/ui/browser_window.h"            // nogncheck
+#include "chrome/browser/renderer_host/chrome_navigation_ui_data.h"
+#include "chrome/browser/ui/tabs/tab_utils.h"        // nogncheck
 #else
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_external.h"
 #include "chrome/browser/ui/browser.h"                             // nogncheck
@@ -322,6 +329,9 @@ WindowController* ExtensionTabUtil::GetControllerInProfileWithId(
     int window_id,
     bool also_match_incognito_profile,
     std::string* error_message) {
+#if BUILDFLAG(IS_ANDROID)
+  return WindowControllerFromBrowser(nullptr);
+#else
   Profile* incognito_profile =
       also_match_incognito_profile
           ? profile->GetPrimaryOTRProfile(/*create_if_needed=*/false)
@@ -342,6 +352,7 @@ WindowController* ExtensionTabUtil::GetControllerInProfileWithId(
   }
 
   return nullptr;
+#endif
 }
 
 int ExtensionTabUtil::GetWindowId(BrowserWindowInterface* browser) {
@@ -378,7 +389,18 @@ api::tabs::Tab ExtensionTabUtil::CreateTabObject(
   tabs::TabInterface* tab_interface =
       tab_list ? tab_list->GetTab(tab_index) : nullptr;
 
+#if BUILDFLAG(IS_ANDROID)
+  WebContents* active_contents = nullptr;
+  for (TabModel* model : TabModelList::models()) {
+    if (model->IsActiveModel()) {
+      active_contents = model->GetActiveWebContents();
+      break;
+    }
+  }
+  bool is_active = contents == active_contents;
+#else
   bool is_active = tab_interface && tab_interface->IsActivated();
+#endif
   tab_object.active = is_active;
   tab_object.selected = is_active;
   tab_object.highlighted = tab_interface && tab_interface->IsSelected();
@@ -907,25 +929,26 @@ bool ExtensionTabUtil::GetSharedStateOfGroup(const tab_groups::TabGroupId& id) {
   return saved_group->is_shared_tab_group();
 }
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+// #if BUILDFLAG(ENABLE_EXTENSIONS)
 // static
 std::optional<api::tab_groups::TabGroup> ExtensionTabUtil::CreateTabGroupObject(
     const tab_groups::TabGroupId& id) {
-  Browser* browser = chrome::FindBrowserWithGroup(id, nullptr);
-  if (!browser) {
-    return std::nullopt;
-  }
+  // Browser* browser = chrome::FindBrowserWithGroup(id, nullptr);
+  // if (!browser) {
+  //   return std::nullopt;
+  // }
 
-  CHECK(browser->tab_strip_model()->SupportsTabGroups());
-  TabGroupModel* group_model = browser->tab_strip_model()->group_model();
-  const tab_groups::TabGroupVisualData* visual_data =
-      group_model->GetTabGroup(id)->visual_data();
+  // CHECK(browser->tab_strip_model()->SupportsTabGroups());
+  // TabGroupModel* group_model = browser->tab_strip_model()->group_model();
+  // const tab_groups::TabGroupVisualData* visual_data =
+  //     group_model->GetTabGroup(id)->visual_data();
 
-  DCHECK(visual_data);
+  // DCHECK(visual_data);
 
-  return CreateTabGroupObject(id, *visual_data);
+  // return CreateTabGroupObject(id, *visual_data);
+  return std::nullopt;
 }
-#endif  // BUILDFLAG(ENABLE_EXTENSIONS)
+// #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
 // static
 api::tab_groups::Color ExtensionTabUtil::ColorIdToColor(
@@ -1282,13 +1305,50 @@ WindowController* ExtensionTabUtil::GetWindowControllerOfTab(
   return nullptr;
 }
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if BUILDFLAG(ENABLE_EXTENSIONS_CORE)
 // static
 bool ExtensionTabUtil::OpenOptionsPageFromAPI(
     const Extension* extension,
     content::BrowserContext* browser_context) {
   if (!OptionsPageInfo::HasOptionsPage(extension))
     return false;
+
+#if BUILDFLAG(IS_ANDROID)
+  for (TabModel* model : TabModelList::models()) {
+    if (!model->IsActiveModel()) {
+      continue;
+    }
+
+    GURL options_url = OptionsPageInfo::GetOptionsPage(extension);
+
+    for (int i = 0; i < model->GetTabCount(); i++) {
+      TabAndroid* tab = model->GetTabAt(i);
+      GURL tab_url = tab->GetURL();
+      if (tab_url.spec().rfind(options_url.spec(), 0) == 0) {
+        model->SetActiveIndex(i);
+        return true;
+      }
+    }
+
+    std::unique_ptr<WebContents> contents =
+        WebContents::Create(WebContents::CreateParams(browser_context));
+    content::NavigationController::LoadURLParams load_params(options_url);
+    load_params.transition_type = ui::PageTransitionFromInt(
+    ui::PAGE_TRANSITION_TYPED | ui::PAGE_TRANSITION_FROM_ADDRESS_BAR);
+    contents->GetController().LoadURLWithParams(load_params);
+    contents->GetOutermostWebContents()->Focus();
+    // WebContents* second_web_contents = contents.release();
+    model->CreateTab(
+        nullptr, // parent
+        std::move(contents),
+        TabModel::kInvalidIndex,
+        TabModel::TabLaunchType::FROM_RECENT_TABS_FOREGROUND,
+        /*should_pin=*/false);
+    return true;
+  }
+  return false;
+#else
+
   Profile* profile = Profile::FromBrowserContext(browser_context);
   // This version of OpenOptionsPage() is only called when the extension
   // initiated the command via chrome.runtime.openOptionsPage. For a spanning
@@ -1301,6 +1361,7 @@ bool ExtensionTabUtil::OpenOptionsPageFromAPI(
   if (!browser)
     return false;
   return extensions::ExtensionTabUtil::OpenOptionsPage(extension, browser);
+#endif
 }
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
@@ -1316,7 +1377,7 @@ bool ExtensionTabUtil::OpenOptionsPage(const Extension* extension,
                                                                open_in_tab);
 }
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if BUILDFLAG(ENABLE_EXTENSIONS_CORE)
 // static
 bool ExtensionTabUtil::BrowserSupportsTabs(BrowserWindowInterface* browser) {
   return browser && browser->GetType() != BrowserWindowInterface::TYPE_DEVTOOLS;
@@ -1359,10 +1420,10 @@ bool ExtensionTabUtil::IsTabStripEditable() {
 
 TabListInterface* ExtensionTabUtil::GetEditableTabList(
     BrowserWindowInterface& browser) {
-  if (!IsTabStripEditable()) {
+  // if (!IsTabStripEditable()) {
     return nullptr;
-  }
-  return TabListInterface::From(&browser);
+  // }
+  // return TabListInterface::From(&browser);
 }
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
diff --git a/chrome/browser/extensions/extension_tab_util.h b/chrome/browser/extensions/extension_tab_util.h
index 5ae58aa046601d..6febf69ddba846 100644
--- a/chrome/browser/extensions/extension_tab_util.h
+++ b/chrome/browser/extensions/extension_tab_util.h
@@ -21,6 +21,8 @@
 #include "extensions/buildflags/buildflags.h"
 #include "extensions/common/mojom/context_type.mojom-forward.h"
 #include "ui/base/window_open_disposition.h"
+// #include "chrome/browser/ui/android/tab_model/tab_model.h"
+#include "chrome/browser/android/tab_android.h"
 
 static_assert(BUILDFLAG(ENABLE_EXTENSIONS_CORE));
 
@@ -225,10 +227,10 @@ class ExtensionTabUtil {
   static api::tab_groups::TabGroup CreateTabGroupObject(
       const tab_groups::TabGroupId& id,
       const tab_groups::TabGroupVisualData& visual_data);
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+// #if BUILDFLAG(ENABLE_EXTENSIONS)
   static std::optional<api::tab_groups::TabGroup> CreateTabGroupObject(
       const tab_groups::TabGroupId& id);
-#endif  // BUILDFLAG(ENABLE_EXTENSIONS)
+// #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
   // Conversions between the api::tab_groups::Color enum and the TabGroupColorId
   // enum.
@@ -303,7 +305,7 @@ class ExtensionTabUtil {
   static WindowController* GetWindowControllerOfTab(
       content::WebContents* web_contents);
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if BUILDFLAG(ENABLE_EXTENSIONS_CORE)
   // Open the extension's options page. Returns true if an options page was
   // successfully opened (though it may not necessarily *load*, e.g. if the
   // URL does not exist). This call to open the options page is iniatiated by
@@ -318,7 +320,7 @@ class ExtensionTabUtil {
   static bool OpenOptionsPage(const Extension* extension,
                               BrowserWindowInterface* browser);
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if BUILDFLAG(ENABLE_EXTENSIONS_CORE)
   // Returns true if the given Browser can report tabs to extensions.
   // Example of Browsers which don't support tabs include apps and devtools.
   static bool BrowserSupportsTabs(BrowserWindowInterface* browser);
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings.grd b/chrome/browser/ui/android/strings/android_chrome_strings.grd
index 425d6ab1898ba4..80d283374b75dd 100644
--- a/chrome/browser/ui/android/strings/android_chrome_strings.grd
+++ b/chrome/browser/ui/android/strings/android_chrome_strings.grd
@@ -4287,6 +4287,9 @@ To change this setting, <ph name="BEGIN_LINK">BEGIN_LINK</ph>delete the Chrome d
       <message name="IDS_MENU_CHROME_WEBSTORE" desc="Menu item for opening the chrome webstore that allows the user to install extensions. [CHAR_LIMIT=27]">
         Visit Chrome Web Store
       </message>
+      <message name="IDS_MENU_DEV_TOOLS" desc="The text label of the Developer Tools menu item">
+        Developer tools
+      </message>
       <message name="IDS_MENU_TINKER_TANK" desc="Menu item for opening the tinker tank bottom sheet. [CHAR_LIMIT=27]" translateable="false">
         Tinker tank
       </message>
diff --git a/chrome/browser/ui/android/tab_model/tab_model.cc b/chrome/browser/ui/android/tab_model/tab_model.cc
index 74313b8fc294e6..aa08c3fcf4b8f2 100644
--- a/chrome/browser/ui/android/tab_model/tab_model.cc
+++ b/chrome/browser/ui/android/tab_model/tab_model.cc
@@ -7,6 +7,7 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/notimplemented.h"
 #include "build/android_buildflags.h"
+#include "base/strings/utf_string_conversions.h"
 #include "chrome/browser/android/tab_android.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/profiles/profile.h"
@@ -14,19 +15,48 @@
 #include "chrome/browser/sync/session_sync_service_factory.h"
 #include "chrome/browser/sync/sessions/sync_sessions_web_contents_router.h"
 #include "chrome/browser/sync/sessions/sync_sessions_web_contents_router_factory.h"
+#include "chrome/browser/ui/browser_window/public/browser_window_interface.h"
+#include "chrome/browser/resource_coordinator/tab_lifecycle_unit_external.h"
 #include "components/omnibox/browser/location_bar_model_impl.h"
 #include "components/sessions/core/session_id.h"
 #include "components/sync_sessions/open_tabs_ui_delegate.h"
 #include "components/sync_sessions/session_sync_service.h"
 #include "ui/base/unowned_user_data/scoped_unowned_user_data.h"
 
-#if BUILDFLAG(IS_DESKTOP_ANDROID)
+// #if BUILDFLAG(IS_DESKTOP_ANDROID)
 #include "chrome/browser/ui/browser_window/public/browser_window_interface.h"  // nogncheck
-#endif
+// #endif
+
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "content/public/browser/navigation_entry.h"
+#include "content/public/browser/favicon_status.h"
+#include "chrome/browser/ui/recently_audible_helper.h"
+#include "content/public/browser/navigation_controller.h"
 
 using chrome::android::ActivityType;
 
 namespace {
+// Must match Java Tab.INVALID_TAB_ID.
+// doesn't seems ok to have it here but googlers have it all over the project so we can afford not to care about it
+// unless they all of the sudden decide to become decent coders (which is very much unlikely, if history is any indication)
+// static constexpr int kInvalidTabId = -1;
+// from chrome/browser/extensions/browser_extension_window_controller.cc
+// and it's very very VERY wrong!!!
+constexpr char kAlwaysOnTopKey[] = "alwaysOnTop";
+constexpr char kFocusedKey[] = "focused";
+constexpr char kHeightKey[] = "height";
+constexpr char kIncognitoKey[] = "incognito";
+constexpr char kLeftKey[] = "left";
+constexpr char kShowStateKey[] = "state";
+constexpr char kTopKey[] = "top";
+constexpr char kWidthKey[] = "width";
+constexpr char kWindowTypeKey[] = "type";
+constexpr char kShowStateValueNormal[] = "normal";
+// this one from extensions/common/constants.h it's still wrong to have it here
+inline constexpr char kId[] = "id";
+// end of wrongness
+
 sync_sessions::OpenTabsUIDelegate* GetOpenTabsUIDelegate(Profile* profile) {
   sync_sessions::SessionSyncService* service =
       SessionSyncServiceFactory::GetForProfile(profile);
@@ -70,6 +100,146 @@ TabModel::TabModel(Profile* profile, ActivityType activity_type)
 
 TabModel::~TabModel() = default;
 
+// stick to BrowserExtensionWindowController::CreateWindowValueForExtension
+// from chrome/browser/extensions/browser_extension_window_controller.cc
+base::Value::Dict
+TabModel::CreateWindowValueForExtension(
+    const extensions::Extension* extension,
+    extensions::WindowController::PopulateTabBehavior populate_tab_behavior,
+    extensions::mojom::ContextType context) {
+  base::Value::Dict dict;
+
+  dict.Set(kId, GetSessionId().id());
+  dict.Set(kWindowTypeKey, extensions::api::tabs::ToString(extensions::api::tabs::WindowType::kNormal));
+  dict.Set(kFocusedKey, IsActiveModel());
+  const Profile* profile = GetProfile();
+  dict.Set(kIncognitoKey, profile->IsOffTheRecord());
+  dict.Set(kAlwaysOnTopKey, false);
+
+  dict.Set(kShowStateKey, kShowStateValueNormal);
+
+  TabAndroid* tab = GetTabAt(GetActiveIndex()); // may be 0?
+  if (tab) {
+    gfx::Rect bounds = tab->GetBounds();
+    dict.Set(kLeftKey, bounds.x());
+    dict.Set(kTopKey, bounds.y());
+    dict.Set(kWidthKey, bounds.width());
+    dict.Set(kHeightKey, bounds.height());
+  }
+
+  if (populate_tab_behavior == extensions::WindowController::kPopulateTabs) {
+    dict.Set(extensions::ExtensionTabUtil::kTabsKey, CreateTabList(extension, context));
+  }
+
+  return dict;
+}
+
+base::Value::List TabModel::CreateTabList(
+    const extensions::Extension* extension,
+    extensions::mojom::ContextType context) {
+  base::Value::List tab_list;
+  for (int i = 0; i < GetTabCount(); ++i) {
+     auto* tab = GetTabAt(i);
+     auto* contents = tab->web_contents();
+     extensions::ExtensionTabUtil::ScrubTabBehavior scrub_tab_behavior =
+    extensions::ExtensionTabUtil::GetScrubTabBehavior(extension, context, contents);
+    tab_list.Append(extensions::ExtensionTabUtil::CreateTabObject(contents, scrub_tab_behavior, extension, this, i)
+                        .ToValue());
+  }
+
+  return tab_list;
+}
+
+// extensions::api::tabs::Tab TabModel::CreateTabObject(
+//     const extensions::Extension* extension,
+//     int tab_index) const {
+//   extensions::api::tabs::Tab tab_object;
+//   auto* tab = GetTabAt(tab_index);
+//   tab_object.index = tab_index;
+//   tab_object.id = tab->GetTabId().id();
+//   tab_object.window_id = tab->GetWindowId().id();
+//   auto* contents = tab->web_contents();
+//   if (contents) {
+//     tab_object.last_accessed =
+//       contents->GetLastActiveTime().InMillisecondsFSinceUnixEpoch();
+
+//     gfx::Size contents_size = contents->GetContainerBounds().size();
+//     tab_object.width = contents_size.width();
+//     tab_object.height = contents_size.height();
+
+//     tab_object.url = contents->GetLastCommittedURL().spec(); // or GetUrl() ??
+//     content::NavigationEntry* pending_entry = contents->GetController().GetPendingEntry();
+//     if (pending_entry) {
+//       tab_object.pending_url = pending_entry->GetVirtualURL().spec();
+//     }
+//     tab_object.title = base::UTF16ToUTF8(contents->GetTitle());
+
+    // TODO(tjudkins) This should probably use the LastCommittedEntry() for
+    // consistency.
+//     content::NavigationEntry* visible_entry = contents->GetController().GetVisibleEntry();
+//     if (visible_entry && visible_entry->GetFavicon().valid) {
+//       tab_object.fav_icon_url = visible_entry->GetFavicon().url.spec();
+//     }
+
+//     auto* audible_helper = RecentlyAudibleHelper::FromWebContents(contents); // TODO does it work?
+//     bool audible = false;
+//     if (audible_helper) {
+//       // WebContents in a tab strip have RecentlyAudible helpers. They endow the
+//       // tab with a notion of audibility that has a timeout for quiet periods. Use
+//       // that if available.
+//       audible = audible_helper->WasRecentlyAudible();
+//     } else {
+//       // Otherwise use the instantaneous notion of audibility.
+//       audible = contents->IsCurrentlyAudible();
+//     }
+//     tab_object.audible = audible;
+//     tab_object.muted_info = extensions::ExtensionTabUtil::CreateMutedInfo(contents);
+
+//     tab_object.status = extensions::ExtensionTabUtil::GetLoadingStatus(contents);
+//   }
+
+//   tab_object.discarded = tab->NeedsReload();
+//   tab_object.auto_discardable = true;
+//   tab_object.frozen = tab->IsFrozen();
+//   tab_object.active = tab_index == GetActiveIndex();
+//   tab_object.selected = tab_index == GetActiveIndex();
+//   tab_object.highlighted = tab_index == GetActiveIndex();
+//   tab_object.pinned = live_tab_context_->IsTabPinned(tab_index);
+
+//   tab_object.group_id = -1;
+//   // std::optional<tab_groups::TabGroupId> group = tab->GetTabGroupId();
+//   std::optional<base::Token> group = tab->GetTabGroupId();
+//   if (group.has_value()) {
+//     tab_object.group_id = extensions::ExtensionTabUtil::GetGroupId(
+//       tab_groups::TabGroupId::FromRawToken(*group)
+//     );
+//   }
+
+//   tab_object.incognito = tab->IsIncognito();
+
+//   int parent_id = tab->GetParentId(); // it's android id
+//   tab_object.opener_tab_id = 0;
+//   if (parent_id != kInvalidTabId) {
+//     bool opener_is_alive = false;
+//     // that's very very bad, we do brutforce because of poor TabModel design
+//     // we need something like TabModel::Includes(tabId)
+//     for (int i=0; i < GetTabCount(); i++) {
+//       auto* curr_tab = GetTabAt(i);
+//       if (curr_tab->GetAndroidId() == parent_id) { // compare with android id
+//         parent_id = curr_tab->GetTabId().id(); // now we can get conventional tab id
+//         opener_is_alive = true;
+//         break;
+//       }
+//     }
+//     if (opener_is_alive && parent_id > 0) {
+//       tab_object.opener_tab_id = parent_id;
+//     }
+//   }
+
+//   // ScrubTabForExtension(extension, contents, &tab_object, scrub_tab_behavior);
+//   return tab_object;
+// }
+
 Profile* TabModel::GetProfile() const {
   return profile_;
 }
@@ -158,7 +328,7 @@ void TabModel::RecordActualSyncedTabsHistogram() {
 
 // TODO(http://crbug.com/444518651): remove the if-def when
 // |BrowserWindowInterface| is compiled into all Android builds.
-#if BUILDFLAG(IS_DESKTOP_ANDROID)
+// #if BUILDFLAG(IS_DESKTOP_ANDROID)
 void TabModel::SetSessionId(SessionID session_id) {
   session_id_ = session_id;
 }
@@ -170,4 +340,4 @@ TabListInterface* TabListInterface::From(
   return ui::ScopedUnownedUserData<TabModel>::Get(
       browser_window_interface->GetUnownedUserDataHost());
 }
-#endif
+// #endif
diff --git a/chrome/browser/ui/android/tab_model/tab_model.h b/chrome/browser/ui/android/tab_model/tab_model.h
index cd4213085514a2..3a12ac624b3864 100644
--- a/chrome/browser/ui/android/tab_model/tab_model.h
+++ b/chrome/browser/ui/android/tab_model/tab_model.h
@@ -18,7 +18,10 @@
 #include "components/sessions/core/session_id.h"
 #include "components/sync_sessions/synced_window_delegate.h"
 #include "ui/base/unowned_user_data/scoped_unowned_user_data.h"
+#include "extensions/common/extension.h"
 
+#include "chrome/browser/extensions/window_controller.h"
+#include "extensions/common/mojom/context_type.mojom.h"
 struct NavigateParams;
 
 namespace browser_sync {
@@ -234,6 +237,22 @@ class TabModel : public TabListInterface {
   TabModel(const TabModel&) = delete;
   TabModel& operator=(const TabModel&) = delete;
 
+
+  virtual base::Value::Dict CreateWindowValueForExtension(
+    const extensions::Extension* extension,
+    extensions::WindowController::PopulateTabBehavior populate_tab_behavior,
+    extensions::mojom::ContextType context);
+  virtual base::Value::List CreateTabList(
+    const extensions::Extension* extension,
+    extensions::mojom::ContextType context);
+  // virtual extensions::api::tabs::Tab CreateTabObject(
+  //   const extensions::Extension* extension,
+  //   int tab_index) const;
+  // virtual tab_groups::TabGroupId CreateTabGroup(std::vector<tabs::TabHandle>& tabs) const = 0;
+  virtual bool AddTabsToTabGroup(std::vector<int>, int) const = 0;
+  // virtual bool Ungroup(std::vector<int>) const = 0;
+  // virtual void MoveTab(int id, int newIndex) const = 0;
+
   virtual Profile* GetProfile() const;
   virtual bool IsOffTheRecord() const;
   virtual sync_sessions::SyncedWindowDelegate* GetSyncedWindowDelegate() const;
@@ -301,7 +320,7 @@ class TabModel : public TabListInterface {
 
   LocationBarModel* GetLocationBarModel();
 
-#if BUILDFLAG(IS_DESKTOP_ANDROID)
+// #if BUILDFLAG(IS_DESKTOP_ANDROID)
   // Sets the |SessionID|.
   //
   // This is only needed on desktop Android, where |BrowserWindowInterface|
@@ -311,7 +330,7 @@ class TabModel : public TabListInterface {
   // TODO(http://crbug.com/444518651): remove the if-def when
   // |BrowserWindowInterface| is compiled into all Android builds.
   void SetSessionId(SessionID sessionId);
-#endif
+// #endif
 
  private:
   raw_ptr<Profile, DanglingUntriaged> profile_;
diff --git a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc
index a4193bfaf4d50a..71201324438eb8 100644
--- a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc
+++ b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.cc
@@ -36,6 +36,9 @@
 #include "components/tab_groups/tab_group_id.h"
 #include "components/tab_groups/tab_group_visual_data.h"
 #include "content/public/browser/render_frame_host.h"
+// #include "chrome/browser/ui/browser_window/internal/android/android_browser_window.h"
+#include "chrome/browser/ui/browser_window/public/browser_window_interface.h"
+#include "chrome/browser/ui/browser_window/public/browser_window_interface_iterator.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/common/content_features.h"
 #include "content/public/common/resource_request_body_android.h"
@@ -358,6 +361,29 @@ WebContents* TabModelJniBridge::GetWebContentsAt(int index) const {
   return tab == nullptr ? nullptr : tab->web_contents();
 }
 
+bool TabModelJniBridge::AddTabsToTabGroup(std::vector<int> indices, int destination) const {
+  JNIEnv* env = base::android::AttachCurrentThread();
+
+  ScopedJavaLocalRef<jintArray> java_array =
+    base::android::ToJavaIntArray(env, indices);
+
+  return Java_TabModelJniBridge_addTabsToTabGroup(env, java_object_.get(env), java_array, destination);
+}
+
+// tab_groups::TabGroupId TabModelJniBridge::CreateTabGroup(std::vector<int> indices) const {
+//   JNIEnv* env = base::android::AttachCurrentThread();
+
+//   ScopedJavaLocalRef<jintArray> java_array =
+//     base::android::ToJavaIntArray(env, indices);
+
+//   auto java_token = Java_TabModelJniBridge_createTabGroup(env, java_object_.get(env), java_array);
+//   if (java_token) {
+//     base::Token token = base::android::TokenAndroid::FromJavaToken(env, java_token);
+//     return tab_groups::TabGroupId::FromRawToken(token);
+//   }
+//   return tab_groups::TabGroupId::CreateEmpty();
+// }
+
 TabAndroid* TabModelJniBridge::GetTabAt(int index) const {
   JNIEnv* env = AttachCurrentThread();
   return Java_TabModelJniBridge_getTabAt(env, java_object_.get(env), index);
@@ -639,9 +665,10 @@ std::optional<tab_groups::TabGroupId> TabModelJniBridge::CreateTabGroup(
   JNIEnv* env = AttachCurrentThread();
   ScopedJavaLocalRef<jobject> jobj = java_object_.get(env);
   std::vector<TabAndroid*> tabs_to_add = GetAllTabsFromHandles(tabs);
-  std::optional<base::Token> group_id_token =
-      Java_TabModelJniBridge_createTabGroup(env, jobj, tabs_to_add);
-  return tab_groups::TabGroupId::FromOptionalToken(group_id_token);
+  // std::optional<base::Token> group_id_token =
+  //     Java_TabModelJniBridge_createTabGroup(env, jobj, tabs_to_add);
+  // return tab_groups::TabGroupId::FromOptionalToken(group_id_token);
+  return std::nullopt;
 }
 
 void TabModelJniBridge::SetTabGroupTitle(tab_groups::TabGroupId group_id,
diff --git a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h
index 8c2c42bd47af98..503cf4e1a7dd95 100644
--- a/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h
+++ b/chrome/browser/ui/android/tab_model/tab_model_jni_bridge.h
@@ -66,6 +66,9 @@ class TabModelJniBridge : public TabModel {
   void AddTabListInterfaceObserver(TabListInterfaceObserver* observer) override;
   void RemoveTabListInterfaceObserver(
       TabListInterfaceObserver* observer) override;
+  // tab_groups::TabGroupId CreateTabGroup(std::vector<int>) const override;
+  bool AddTabsToTabGroup(std::vector<int>, int) const override;
+  // bool Ungroup(std::vector<int>) const override;
   int GetTabCount() const override;
   int GetActiveIndex() const override;
   tabs::TabInterface* GetActiveTab() override;
diff --git a/chrome/browser/ui/browser_navigator.cc b/chrome/browser/ui/browser_navigator.cc
index 090c52c00dcf44..989cda86782e90 100644
--- a/chrome/browser/ui/browser_navigator.cc
+++ b/chrome/browser/ui/browser_navigator.cc
@@ -64,9 +64,9 @@
 #include "ui/display/screen.h"
 #include "url/url_constants.h"
 
-#if BUILDFLAG(IS_ANDROID)
-#error This file should only be included on desktop.
-#endif  // BUILDFLAG(IS_ANDROID)
+// #if BUILDFLAG(IS_ANDROID)
+// #error This file should only be included on desktop.
+// #endif  // BUILDFLAG(IS_ANDROID)
 
 #include "chrome/browser/ui/web_applications/navigation_capturing_process.h"
 #include "chrome/browser/ui/web_applications/web_app_launch_utils.h"
@@ -113,22 +113,24 @@ bool WindowCanOpenTabs(const NavigateParams& params) {
     return false;
   }
 
-  return params.browser->GetBrowserForMigrationOnly()->CanSupportWindowFeature(
-             Browser::WindowFeature::kFeatureTabStrip) ||
-         params.browser->GetBrowserForMigrationOnly()
-             ->tab_strip_model()
-             ->empty();
+  // return params.browser->GetBrowserForMigrationOnly()->CanSupportWindowFeature(
+  //            Browser::WindowFeature::kFeatureTabStrip) ||
+  //        params.browser->GetBrowserForMigrationOnly()
+  //            ->tab_strip_model()
+  //            ->empty();
+  return true;
 }
 
 // Finds an existing Browser compatible with |profile|, making a new one if no
 // such Browser is located.
 Browser* GetOrCreateBrowser(Profile* profile, bool user_gesture) {
-  Browser* browser = chrome::FindTabbedBrowser(profile, false);
+  Browser* browser = nullptr;
+  // Browser* browser = chrome::FindTabbedBrowser(profile, false);
 
-  if (!browser && Browser::GetCreationStatusForProfile(profile) ==
-                      Browser::CreationStatus::kOk) {
-    browser = Browser::Create(Browser::CreateParams(profile, user_gesture));
-  }
+  // if (!browser && Browser::GetCreationStatusForProfile(profile) ==
+  //                     Browser::CreationStatus::kOk) {
+  //   browser = Browser::Create(Browser::CreateParams(profile, user_gesture));
+  // }
   return browser;
 }
 
@@ -160,31 +162,31 @@ bool AdjustNavigateParamsForURL(NavigateParams* params) {
     params->window_action = NavigateParams::WindowAction::kShowWindow;
   }
 
-  Browser* browser_for_migration =
-      params->browser ? params->browser->GetBrowserForMigrationOnly() : nullptr;
+  // Browser* browser_for_migration =
+  //     params->browser ? params->browser->GetBrowserForMigrationOnly() : nullptr;
 
   // Clicking a link to the home tab in a tabbed web app should always open the
   // link in the home tab.
-  if (web_app::IsHomeTabUrl(browser_for_migration, params->url)) {
-    browser_for_migration->tab_strip_model()->ActivateTabAt(0);
-    // If the navigation URL is the same as the current home tab URL, skip the
-    // navigation.
-    if (browser_for_migration->tab_strip_model()
-            ->GetActiveWebContents()
-            ->GetLastCommittedURL() == params->url) {
-      return false;
-    }
-    params->disposition = WindowOpenDisposition::CURRENT_TAB;
-  }
+  // if (web_app::IsHomeTabUrl(browser_for_migration, params->url)) {
+  //   browser_for_migration->tab_strip_model()->ActivateTabAt(0);
+  //   // If the navigation URL is the same as the current home tab URL, skip the
+  //   // navigation.
+  //   if (browser_for_migration->tab_strip_model()
+  //           ->GetActiveWebContents()
+  //           ->GetLastCommittedURL() == params->url) {
+  //     return false;
+  //   }
+  //   params->disposition = WindowOpenDisposition::CURRENT_TAB;
+  // }
 
   return true;
 }
 
-Browser::ValueSpecified GetOriginSpecified(const NavigateParams& params) {
-  return params.window_features.has_x && params.window_features.has_y
-             ? Browser::ValueSpecified::kSpecified
-             : Browser::ValueSpecified::kUnspecified;
-}
+// Browser::ValueSpecified GetOriginSpecified(const NavigateParams& params) {
+//   return params.window_features.has_x && params.window_features.has_y
+//              ? Browser::ValueSpecified::kSpecified
+//              : Browser::ValueSpecified::kUnspecified;
+// }
 
 // Returns a Browser and tab index. The browser can host the navigation or
 // tab addition specified in |params|.  This might just return the same
@@ -247,81 +249,81 @@ std::tuple<BrowserWindowInterface*, int> GetBrowserAndTabForDisposition(
       // if any.
       std::string app_name;
       if (!params.app_id.empty()) {
-        app_name = web_app::GenerateApplicationNameFromAppId(params.app_id);
+        // app_name = web_app::GenerateApplicationNameFromAppId(params.app_id);
       } else if (params.browser && !params.browser->GetBrowserForMigrationOnly()
                                         ->app_name()
                                         .empty()) {
         app_name = params.browser->GetBrowserForMigrationOnly()->app_name();
       }
 
-      auto browser_params = Browser::CreateParams::CreateForPictureInPicture(
-          app_name, params.trusted_source, profile, params.user_gesture);
-      DCHECK(params.contents_to_insert);
-      auto pip_options =
-          params.contents_to_insert->GetPictureInPictureOptions();
-      if (!pip_options.has_value()) {
+      // auto browser_params = Browser::CreateParams::CreateForPictureInPicture(
+      //     app_name, params.trusted_source, profile, params.user_gesture);
+      // DCHECK(params.contents_to_insert);
+      // auto pip_options =
+      //     params.contents_to_insert->GetPictureInPictureOptions();
+      // if (!pip_options.has_value()) {
         return {nullptr, -1};
-      }
-
-      browser_params.pip_options = pip_options;
-
-      const ui::BaseWindow* const browser_window = params.browser->GetWindow();
-      const gfx::NativeWindow native_window =
-          browser_window ? browser_window->GetNativeWindow()
-                         : gfx::NativeWindow();
-      const display::Screen* const screen = display::Screen::Get();
-      const display::Display display =
-          browser_window ? screen->GetDisplayNearestWindow(native_window)
-                         : screen->GetDisplayForNewWindows();
-
-      browser_params.initial_bounds =
-          PictureInPictureWindowManager::GetInstance()
-              ->CalculateInitialPictureInPictureWindowBounds(*pip_options,
-                                                             display);
-
-      browser_params.omit_from_session_restore = true;
-      return {Browser::Create(browser_params), -1};
+      // }
+
+      // browser_params.pip_options = pip_options;
+
+      // const ui::BaseWindow* const browser_window = params.browser->GetWindow();
+      // const gfx::NativeWindow native_window =
+      //     browser_window ? browser_window->GetNativeWindow()
+      //                    : gfx::NativeWindow();
+      // const display::Screen* const screen = display::Screen::Get();
+      // const display::Display display =
+      //     browser_window ? screen->GetDisplayNearestWindow(native_window)
+      //                    : screen->GetDisplayForNewWindows();
+
+      // browser_params.initial_bounds =
+      //     PictureInPictureWindowManager::GetInstance()
+      //         ->CalculateInitialPictureInPictureWindowBounds(*pip_options,
+      //                                                        display);
+
+      // browser_params.omit_from_session_restore = true;
+      // return {Browser::Create(browser_params), -1};
     }
     case WindowOpenDisposition::NEW_POPUP: {
       // Make a new popup window.
       // Coerce app-style if |source| represents an app.
       std::string app_name;
       if (!params.app_id.empty()) {
-        app_name = web_app::GenerateApplicationNameFromAppId(params.app_id);
+        // app_name = web_app::GenerateApplicationNameFromAppId(params.app_id);
       } else if (params.browser && !params.browser->GetBrowserForMigrationOnly()
                                         ->app_name()
                                         .empty()) {
         app_name = params.browser->GetBrowserForMigrationOnly()->app_name();
       }
-      if (Browser::GetCreationStatusForProfile(profile) !=
-          Browser::CreationStatus::kOk) {
+      // if (Browser::GetCreationStatusForProfile(profile) !=
+      //     Browser::CreationStatus::kOk) {
         return {nullptr, -1};
-      }
-      if (app_name.empty()) {
-        Browser::CreateParams browser_params(Browser::TYPE_POPUP, profile,
-                                             params.user_gesture);
-        browser_params.trusted_source = params.trusted_source;
-        browser_params.initial_bounds = params.window_features.bounds;
-        browser_params.initial_origin_specified = GetOriginSpecified(params);
-        browser_params.can_maximize = !params.is_tab_modal_popup_deprecated;
-        browser_params.can_fullscreen = !params.is_tab_modal_popup_deprecated;
-        return {Browser::Create(browser_params), -1};
-      }
-      Browser::CreateParams browser_params =
-          Browser::CreateParams::CreateForAppPopup(
-              app_name, params.trusted_source, params.window_features.bounds,
-              profile, params.user_gesture);
-      browser_params.initial_origin_specified = GetOriginSpecified(params);
-      return {Browser::Create(browser_params), -1};
+      // }
+      // if (app_name.empty()) {
+      //   Browser::CreateParams browser_params(Browser::TYPE_POPUP, profile,
+      //                                        params.user_gesture);
+      //   browser_params.trusted_source = params.trusted_source;
+      //   browser_params.initial_bounds = params.window_features.bounds;
+      //   browser_params.initial_origin_specified = GetOriginSpecified(params);
+      //   browser_params.can_maximize = !params.is_tab_modal_popup_deprecated;
+      //   browser_params.can_fullscreen = !params.is_tab_modal_popup_deprecated;
+      //   return {Browser::Create(browser_params), -1};
+      // }
+      // Browser::CreateParams browser_params =
+      //     Browser::CreateParams::CreateForAppPopup(
+      //         app_name, params.trusted_source, params.window_features.bounds,
+      //         profile, params.user_gesture);
+      // browser_params.initial_origin_specified = GetOriginSpecified(params);
+      // return {Browser::Create(browser_params), -1};
     }
     case WindowOpenDisposition::NEW_WINDOW: {
       // Make a new normal browser window.
       Browser* browser = nullptr;
-      if (Browser::GetCreationStatusForProfile(profile) ==
-          Browser::CreationStatus::kOk) {
-        browser = Browser::Create(
-            Browser::CreateParams(profile, params.user_gesture));
-      }
+      // if (Browser::GetCreationStatusForProfile(profile) ==
+      //     Browser::CreationStatus::kOk) {
+      //   browser = Browser::Create(
+      //       Browser::CreateParams(profile, params.user_gesture));
+      // }
       return {browser, -1};
     }
     case WindowOpenDisposition::OFF_THE_RECORD:
@@ -343,14 +345,14 @@ std::tuple<BrowserWindowInterface*, int> GetBrowserAndTabForDisposition(
 // conditions.
 void NormalizeDisposition(NavigateParams* params) {
   // Calculate the WindowOpenDisposition if necessary.
-  if (params->browser->GetBrowserForMigrationOnly()
-          ->tab_strip_model()
-          ->empty() &&
-      (params->disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB ||
-       params->disposition == WindowOpenDisposition::CURRENT_TAB ||
-       params->disposition == WindowOpenDisposition::SINGLETON_TAB)) {
-    params->disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
-  }
+  // if (params->browser->GetBrowserForMigrationOnly()
+  //         ->tab_strip_model()
+  //         ->empty() &&
+  //     (params->disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB ||
+  //      params->disposition == WindowOpenDisposition::CURRENT_TAB ||
+  //      params->disposition == WindowOpenDisposition::SINGLETON_TAB)) {
+  //   params->disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
+  // }
   if (params->browser->GetProfile()->IsOffTheRecord() &&
       params->disposition == WindowOpenDisposition::OFF_THE_RECORD) {
     params->disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
@@ -436,8 +438,8 @@ class ScopedBrowserShower {
         CHECK_EQ(params_->disposition, WindowOpenDisposition::NEW_POPUP);
         CHECK_NE(source_contents_, nullptr);
         window->SetIsTabModalPopupDeprecated(true);
-        constrained_window::ShowModalDialog(window->GetNativeWindow(),
-                                            source_contents_);
+        // constrained_window::ShowModalDialog(window->GetNativeWindow(),
+        //                                     source_contents_);
       } else {
         window->Show();
       }
@@ -463,48 +465,48 @@ class ScopedBrowserShower {
   raw_ptr<content::WebContents> source_contents_;
 };
 
-std::unique_ptr<content::WebContents> CreateTargetContents(
-    const NavigateParams& params,
-    const GURL& url) {
-  // Always create the new WebContents in a new SiteInstance (and therefore a
-  // new BrowsingInstance), *unless* there's a |params.opener|.
-  //
-  // Note that the SiteInstance below is only for the "initial" placement of the
-  // new WebContents (i.e. if subsequent navigation [including the initial
-  // navigation] triggers a cross-process transfer, then the opener and new
-  // contents can end up in separate processes).  This is fine, because even if
-  // subsequent navigation is cross-process (i.e. cross-SiteInstance), then it
-  // will stay in the same BrowsingInstance (creating frame proxies as needed)
-  // preserving the requested opener relationship along the way.
-  scoped_refptr<content::SiteInstance> initial_site_instance_for_new_contents =
-      params.opener ? params.opener->GetSiteInstance()
-                    : tab_util::GetSiteInstanceForNewTab(
-                          params.browser->GetProfile(), url);
-
-  WebContents::CreateParams create_params(
-      params.browser->GetProfile(), initial_site_instance_for_new_contents);
-  create_params.main_frame_name = params.frame_name;
-  if (params.opener) {
-    create_params.opener_render_frame_id = params.opener->GetRoutingID();
-    create_params.opener_render_process_id =
-        params.opener->GetProcess()->GetDeprecatedID();
-  }
-
-  create_params.opened_by_another_window = params.opened_by_another_window;
-
-  if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB) {
-    create_params.initially_hidden = true;
-  }
-
-#if defined(USE_AURA)
-  if (params.browser->GetWindow() &&
-      params.browser->GetWindow()->GetNativeWindow()) {
-    create_params.context = params.browser->GetWindow()->GetNativeWindow();
-  }
-#endif
-
-  return WebContents::Create(create_params);
-}
+// std::unique_ptr<content::WebContents> CreateTargetContents(
+//     const NavigateParams& params,
+//     const GURL& url) {
+//   // Always create the new WebContents in a new SiteInstance (and therefore a
+//   // new BrowsingInstance), *unless* there's a |params.opener|.
+//   //
+//   // Note that the SiteInstance below is only for the "initial" placement of the
+//   // new WebContents (i.e. if subsequent navigation [including the initial
+//   // navigation] triggers a cross-process transfer, then the opener and new
+//   // contents can end up in separate processes).  This is fine, because even if
+//   // subsequent navigation is cross-process (i.e. cross-SiteInstance), then it
+//   // will stay in the same BrowsingInstance (creating frame proxies as needed)
+//   // preserving the requested opener relationship along the way.
+//   scoped_refptr<content::SiteInstance> initial_site_instance_for_new_contents =
+//       params.opener ? params.opener->GetSiteInstance()
+//                     : tab_util::GetSiteInstanceForNewTab(
+//                           params.browser->GetProfile(), url);
+
+//   WebContents::CreateParams create_params(
+//       params.browser->GetProfile(), initial_site_instance_for_new_contents);
+//   create_params.main_frame_name = params.frame_name;
+//   if (params.opener) {
+//     create_params.opener_render_frame_id = params.opener->GetRoutingID();
+//     create_params.opener_render_process_id =
+//         params.opener->GetProcess()->GetDeprecatedID();
+//   }
+
+//   create_params.opened_by_another_window = params.opened_by_another_window;
+
+//   if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB) {
+//     create_params.initially_hidden = true;
+//   }
+
+// #if defined(USE_AURA)
+//   if (params.browser->GetWindow() &&
+//       params.browser->GetWindow()->GetNativeWindow()) {
+//     create_params.context = params.browser->GetWindow()->GetNativeWindow();
+//   }
+// #endif
+
+//   return WebContents::Create(create_params);
+// }
 
 }  // namespace
 
@@ -535,10 +537,10 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
     return nullptr;
   }
 
-  if (params->browser &&
-      params->browser->GetBrowserForMigrationOnly()->is_delete_scheduled()) {
-    return nullptr;
-  }
+  // if (params->browser &&
+  //     params->browser->GetBrowserForMigrationOnly()->is_delete_scheduled()) {
+  //   return nullptr;
+  // }
 
   // Block navigation requests when in locked fullscreen mode. We allow
   // navigation requests in the webapp when locked for OnTask (only relevant for
@@ -546,16 +548,16 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
   // TODO(b/365146870): Remove once we consolidate locked fullscreen with
   // OnTask.
   if (source_browser) {
-    bool should_block_navigation =
-        platform_util::IsBrowserLockedFullscreen(source_browser);
+    // bool should_block_navigation =
+    //     platform_util::IsBrowserLockedFullscreen(source_browser);
 #if BUILDFLAG(IS_CHROMEOS)
     if (source_browser->IsLockedForOnTask()) {
       should_block_navigation = false;
     }
 #endif  // BUILDFLAG(IS_CHROMEOS)
-    if (should_block_navigation) {
-      return nullptr;
-    }
+    // if (should_block_navigation) {
+    //   return nullptr;
+    // }
   }
 
   // Open System Apps in their standalone window if necessary.
@@ -609,11 +611,11 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
   // target browser. This must happen before GetBrowserAndTabForDisposition()
   // has a chance to replace |params->browser| with another one, but after the
   // above check that relies on the original source_contents value.
-  if (!params->source_contents && params->browser) {
-    params->source_contents = params->browser->GetBrowserForMigrationOnly()
-                                  ->tab_strip_model()
-                                  ->GetActiveWebContents();
-  }
+  // if (!params->source_contents && params->browser) {
+  //   params->source_contents = params->browser->GetBrowserForMigrationOnly()
+  //                                 ->tab_strip_model()
+  //                                 ->GetActiveWebContents();
+  // }
 
   WebContents* contents_to_navigate_or_insert =
       params->contents_to_insert.get();
@@ -638,25 +640,25 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
       return nullptr;
     }
 
-    PictureInPictureWindowManager::GetInstance()->EnterDocumentPictureInPicture(
-        params->source_contents, contents_to_navigate_or_insert);
+    // PictureInPictureWindowManager::GetInstance()->EnterDocumentPictureInPicture(
+    //     params->source_contents, contents_to_navigate_or_insert);
   }
 
   // TODO(crbug.com/364657540): Revisit integration with web_application system
   // later if needed.
   int singleton_index = -1;
 
-  std::unique_ptr<web_app::NavigationCapturingProcess> app_navigation =
-      web_app::NavigationCapturingProcess::MaybeHandleAppNavigation(*params);
-
-  std::optional<web_app::NavigationCapturingOverride> override_params =
-      app_navigation
-          ? app_navigation->GetInitialNavigationParamsOverride(*params)
-          : std::nullopt;
-  if (override_params) {
-    params->browser = override_params->browser();
-    singleton_index = override_params->tab_index().value_or(-1);
-  } else {
+  std::unique_ptr<web_app::NavigationCapturingProcess> app_navigation = nullptr;
+  //     web_app::NavigationCapturingProcess::MaybeHandleAppNavigation(*params);
+
+  // std::optional<web_app::NavigationCapturingOverride> override_params =
+  //     app_navigation
+  //         ? app_navigation->GetInitialNavigationParamsOverride(*params)
+  //         : std::nullopt;
+  // if (override_params) {
+  //   params->browser = override_params->browser();
+  //   singleton_index = override_params->tab_index().value_or(-1);
+  // } else {
     std::tuple<BrowserWindowInterface*, int> browser_and_index =
         GetBrowserAndTabForDisposition(*params);
     params->browser =
@@ -664,7 +666,7 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
             ? nullptr
             : std::get<0>(browser_and_index)->GetBrowserForMigrationOnly();
     singleton_index = std::get<1>(browser_and_index);
-  }
+  // }
 
   if (!params->browser) {
     return nullptr;
@@ -682,10 +684,10 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
   }
 
   if (singleton_index != -1) {
-    contents_to_navigate_or_insert =
-        params->browser->GetBrowserForMigrationOnly()
-            ->tab_strip_model()
-            ->GetWebContentsAt(singleton_index);
+    // contents_to_navigate_or_insert =
+    //     params->browser->GetBrowserForMigrationOnly()
+    //         ->tab_strip_model()
+    //         ->GetWebContentsAt(singleton_index);
   } else if (params->disposition == WindowOpenDisposition::SWITCH_TO_TAB) {
     // The user is trying to open a tab that no longer exists. If we open a new
     // tab, it could leave orphaned NTPs around, but always overwriting the
@@ -698,7 +700,7 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
   }
   if (content::SiteIsolationPolicy::ShouldUrlUseApplicationIsolationLevel(
           params->initiating_profile, params->url)) {
-    CHECK(web_app::AppBrowserController::IsIsolatedWebApp(params->browser));
+    // CHECK(web_app::AppBrowserController::IsIsolatedWebApp(params->browser));
   }
 #if BUILDFLAG(IS_CHROMEOS)
   if (source_browser && source_browser != params->browser) {
@@ -746,13 +748,13 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
   NormalizeDisposition(params);
 
   // If a new window has been created, it needs to be shown.
-  if (params->window_action == NavigateParams::WindowAction::kNoAction &&
-      source_browser != params->browser &&
-      params->browser->GetBrowserForMigrationOnly()
-          ->tab_strip_model()
-          ->empty()) {
-    params->window_action = NavigateParams::WindowAction::kShowWindow;
-  }
+  // if (params->window_action == NavigateParams::WindowAction::kNoAction &&
+  //     source_browser != params->browser &&
+  //     params->browser->GetBrowserForMigrationOnly()
+  //         ->tab_strip_model()
+  //         ->empty()) {
+  //   params->window_action = NavigateParams::WindowAction::kShowWindow;
+  // }
 
   // If we create a popup window from a non user-gesture, don't activate it.
   if (params->window_action == NavigateParams::WindowAction::kShowWindow &&
@@ -763,17 +765,17 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
 
   // Determine if the navigation was user initiated. If it was, we need to
   // inform the target WebContents, and we may need to update the UI.
-  bool user_initiated =
-      params->transition & ui::PAGE_TRANSITION_FROM_ADDRESS_BAR ||
-      !ui::PageTransitionIsWebTriggerable(params->transition);
+  // bool user_initiated =
+  //     params->transition & ui::PAGE_TRANSITION_FROM_ADDRESS_BAR ||
+  //     !ui::PageTransitionIsWebTriggerable(params->transition);
 
   base::WeakPtr<content::NavigationHandle> navigation_handle;
 
   std::unique_ptr<tabs::TabModel> tab_to_insert;
   if (params->contents_to_insert) {
-    tab_to_insert = std::make_unique<tabs::TabModel>(
-        std::move(params->contents_to_insert),
-        params->browser->GetBrowserForMigrationOnly()->tab_strip_model());
+    // tab_to_insert = std::make_unique<tabs::TabModel>(
+    //     std::move(params->contents_to_insert),
+    //     params->browser->GetBrowserForMigrationOnly()->tab_strip_model());
   }
 
   // If no target WebContents was specified (and we didn't seek and find a
@@ -782,14 +784,14 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
   if (!contents_to_navigate_or_insert) {
     DCHECK(!params->url.is_empty());
     if (params->disposition != WindowOpenDisposition::CURRENT_TAB) {
-      tab_to_insert = std::make_unique<tabs::TabModel>(
-          CreateTargetContents(*params, params->url),
-          params->browser->GetBrowserForMigrationOnly()->tab_strip_model());
-      contents_to_navigate_or_insert = tab_to_insert->GetContents();
-
-      apps::SetAppIdForWebContents(params->browser->GetProfile(),
-                                   contents_to_navigate_or_insert,
-                                   params->app_id);
+      // tab_to_insert = std::make_unique<tabs::TabModel>(
+      //     CreateTargetContents(*params, params->url),
+      //     params->browser->GetBrowserForMigrationOnly()->tab_strip_model());
+      // contents_to_navigate_or_insert = tab_to_insert->GetContents();
+
+      // apps::SetAppIdForWebContents(params->browser->GetProfile(),
+      //                              contents_to_navigate_or_insert,
+      //                              params->app_id);
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
       captive_portal::CaptivePortalTabHelper::FromWebContents(
           contents_to_navigate_or_insert)
@@ -835,20 +837,20 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
     // Save data needed for link capturing into apps that cannot otherwise be
     // inferred later in the navigation. These are only needed when the
     // navigation happens in a different tab to the link click.
-    apps::SetLinkCapturingSourceDisposition(tab_to_insert->GetContents(),
-                                            params->disposition);
+    // apps::SetLinkCapturingSourceDisposition(tab_to_insert->GetContents(),
+    //                                         params->disposition);
   }
 
   if (params->source_contents == contents_to_navigate_or_insert) {
     // The navigation occurred in the source tab.
-    params->browser->GetBrowserForMigrationOnly()->UpdateUIForNavigationInTab(
-        contents_to_navigate_or_insert, params->transition,
-        params->window_action, user_initiated);
+    // params->browser->GetBrowserForMigrationOnly()->UpdateUIForNavigationInTab(
+    //     contents_to_navigate_or_insert, params->transition,
+    //     params->window_action, user_initiated);
   } else if (singleton_index == -1) {
     if (source_browser != params->browser) {
-      params->tabstrip_index = params->browser->GetBrowserForMigrationOnly()
-                                   ->tab_strip_model()
-                                   ->count();
+      // params->tabstrip_index = params->browser->GetBrowserForMigrationOnly()
+      //                              ->tab_strip_model()
+      //                              ->count();
     }
 
     // If some non-default value is set for the index, we should tell the
@@ -868,9 +870,9 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
 
     DCHECK(tab_to_insert);
     // The navigation should insert a new tab into the target Browser.
-    params->browser->GetBrowserForMigrationOnly()->tab_strip_model()->AddTab(
-        std::move(tab_to_insert), params->tabstrip_index, params->transition,
-        params->tabstrip_add_types, params->group);
+    // params->browser->GetBrowserForMigrationOnly()->tab_strip_model()->AddTab(
+    //     std::move(tab_to_insert), params->tabstrip_index, params->transition,
+    //     params->tabstrip_add_types, params->group);
   }
 
   if (singleton_index >= 0) {
@@ -897,9 +899,9 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
     if (params->source_contents != contents_to_navigate_or_insert) {
       // Use the index before the potential close below, because it could
       // make the index refer to a different tab.
-      auto gesture_type = user_initiated
-                              ? TabStripUserGestureDetails::GestureType::kOther
-                              : TabStripUserGestureDetails::GestureType::kNone;
+      // auto gesture_type = user_initiated
+      //                         ? TabStripUserGestureDetails::GestureType::kOther
+      //                         : TabStripUserGestureDetails::GestureType::kNone;
       bool should_close_this_tab = false;
       if (params->disposition == WindowOpenDisposition::SWITCH_TO_TAB) {
         // Close orphaned NTP (and the like) with no history when the user
@@ -917,10 +919,10 @@ base::WeakPtr<content::NavigationHandle> Navigate(NavigateParams* params) {
           }
         }
       }
-      params->browser->GetBrowserForMigrationOnly()
-          ->tab_strip_model()
-          ->ActivateTabAt(singleton_index,
-                          TabStripUserGestureDetails(gesture_type));
+      // params->browser->GetBrowserForMigrationOnly()
+      //     ->tab_strip_model()
+      //     ->ActivateTabAt(singleton_index,
+      //                     TabStripUserGestureDetails(gesture_type));
       // Close tab after switch so index remains correct.
       if (should_close_this_tab) {
         params->source_contents->Close();
diff --git a/chrome/browser/ui/browser_navigator_params.cc b/chrome/browser/ui/browser_navigator_params.cc
index 9989136605eed0..e7c2739240eb81 100644
--- a/chrome/browser/ui/browser_navigator_params.cc
+++ b/chrome/browser/ui/browser_navigator_params.cc
@@ -17,9 +17,9 @@
 #include "chrome/browser/ui/browser.h"
 #endif
 
-#if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
 #include "chrome/browser/ui/browser_window/public/browser_window_interface.h"  // nogncheck
-#endif
+// #endif
 
 using content::GlobalRequestID;
 using content::NavigationController;
@@ -30,7 +30,7 @@ NavigateParams::NavigateParams(std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)) {}
 #endif
 
-#if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
 NavigateParams::NavigateParams(BrowserWindowInterface* a_browser,
                                const GURL& a_url,
                                ui::PageTransition a_transition)
@@ -39,7 +39,7 @@ NavigateParams::NavigateParams(BrowserWindowInterface* a_browser,
 NavigateParams::NavigateParams(BrowserWindowInterface* a_browser,
                                std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)), browser(a_browser) {}
-#endif
+// #endif
 
 NavigateParams::NavigateParams(Profile* a_profile,
                                const GURL& a_url,
diff --git a/chrome/browser/ui/browser_navigator_params.h b/chrome/browser/ui/browser_navigator_params.h
index 88e9f20fb8eb5e..7ff3214e3005e6 100644
--- a/chrome/browser/ui/browser_navigator_params.h
+++ b/chrome/browser/ui/browser_navigator_params.h
@@ -33,9 +33,9 @@
 #include "ui/base/window_open_disposition.h"
 #include "url/gurl.h"
 
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
 #include "components/tab_groups/tab_group_id.h"
-#endif
+// #endif
 
 class Browser;
 class BrowserWindowInterface;
@@ -71,18 +71,18 @@ struct OpenURLParams;
 
 // TODO(thestig): Split or ifdef out more fields that are not used on Android.
 struct NavigateParams {
-#if BUILDFLAG(IS_ANDROID)
+// #if BUILDFLAG(IS_ANDROID)
   explicit NavigateParams(
       std::unique_ptr<content::WebContents> contents_to_insert);
-#endif
+// #endif
 
-#if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
   NavigateParams(BrowserWindowInterface* a_browser,
                  const GURL& a_url,
                  ui::PageTransition a_transition);
   NavigateParams(BrowserWindowInterface* a_browser,
                  std::unique_ptr<content::WebContents> contents_to_insert);
-#endif
+// #endif
 
   NavigateParams(Profile* profile,
                  const GURL& a_url,
@@ -263,7 +263,7 @@ struct NavigateParams {
   };
   PathBehavior path_behavior = RESPECT;
 
-#if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_DESKTOP_ANDROID)
   // [in]  Specifies a BrowserWindowInterface object where the navigation
   //       could occur or the tab could be added. Navigate() is not obliged to
   //       use this BrowserWindowInterface if it is not compatible with the
@@ -279,9 +279,9 @@ struct NavigateParams {
   //       (Browser objects are deleted when the user closes a visible browser
   //       window).
   raw_ptr<BrowserWindowInterface, AcrossTasksDanglingUntriaged> browser;
-#endif
+// #endif
 
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
   // The group the caller would like the tab to be added to.
   std::optional<tab_groups::TabGroupId> group;
 
@@ -296,7 +296,7 @@ struct NavigateParams {
   // determine where to insert a new tab and whether or not it should be
   // selected, among other properties.
   int tabstrip_add_types = AddTabTypes::ADD_ACTIVE;
-#endif
+// #endif
 
   // The profile that is initiating the navigation. If there is a non-NULL
   // browser passed in via |browser|, it's profile will be used instead.
diff --git a/chrome/browser/ui/browser_window/public/browser_window_interface.h b/chrome/browser/ui/browser_window/public/browser_window_interface.h
index 2097328e2ea57f..43df44258dc5d4 100644
--- a/chrome/browser/ui/browser_window/public/browser_window_interface.h
+++ b/chrome/browser/ui/browser_window/public/browser_window_interface.h
@@ -11,6 +11,7 @@
 #include "build/build_config.h"
 #include "content/public/browser/page_navigator.h"
 
+#include "base/callback_list.h"
 #if !BUILDFLAG(IS_ANDROID)
 #include "ui/base/window_open_disposition.h"
 #endif
@@ -137,10 +138,10 @@ class BrowserWindowInterface : public content::PageNavigator {
     // * Legacy packaged app ("v1 packaged app")
     // * Hosted app (e.g. the Web Store "app" preinstalled on Chromebooks)
     TYPE_APP,
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
     // Devtools browser.
     TYPE_DEVTOOLS,
-#endif
+// #endif
     // App popup browser. It behaves like an app browser (e.g. it should have an
     // AppBrowserController) but looks like a popup (e.g. it never has a tab
     // strip).
@@ -153,12 +154,12 @@ class BrowserWindowInterface : public content::PageNavigator {
     // CustomTabToolbarview.
     TYPE_CUSTOM_TAB,
 #endif
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
     // Document picture-in-picture browser.  It's mostly the same as a
     // TYPE_POPUP, except that it floats above other windows.  It also has some
     // additional restrictions, like it cannot navigated, to prevent misuse.
     TYPE_PICTURE_IN_PICTURE,
-#endif
+// #endif
     // If you add a new type, consider updating the test
     // BrowserTest.StartMaximized.
   };
diff --git a/chrome/common/pref_names.h b/chrome/common/pref_names.h
index e2e204383d3c82..63ee5da27263d7 100644
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -1933,7 +1933,7 @@ inline constexpr char kSuppressDifferentOriginSubframeJSDialogs[] =
 // or disabled. Defaults to blink::features::kReduceUserAgent field trial.
 inline constexpr char kUserAgentReduction[] = "user_agent_reduction";
 
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
 // Boolean determining the side the side panel will be appear on (left / right).
 // True when the side panel is aligned to the right.
 inline constexpr char kSidePanelHorizontalAlignment[] =
@@ -1954,7 +1954,7 @@ inline constexpr char kTabSearchRightAligned[] = "tab_search.is_right_aligned";
 
 // Boolean determining whether vertical tabs are enabled.
 inline constexpr char kVerticalTabsEnabled[] = "vertical_tabs.enabled";
-#endif  // !BUILDFLAG(IS_ANDROID)
+// #endif  // !BUILDFLAG(IS_ANDROID)
 
 #if BUILDFLAG(ENABLE_COMPOSE)
 // Boolean indicating whether or not the Compose FRE has been completed.
@@ -2412,7 +2412,7 @@ inline constexpr char kNtpCustomBackgroundLocalToDeviceId[] =
 inline constexpr char kNtpCustomBackgroundInspiration[] =
     "ntp.custom_background_inspiration";
 
-#if BUILDFLAG(IS_ANDROID)
+// #if BUILDFLAG(IS_ANDROID)
 // Keeps track of recently closed tabs collapsed state in the Other Devices
 // menu.
 inline constexpr char kNtpCollapsedRecentlyClosedTabs[] =
@@ -2424,7 +2424,7 @@ inline constexpr char kNtpCollapsedSnapshotDocument[] =
 
 // Keeps track of sync promo collapsed state in the Other Devices menu.
 inline constexpr char kNtpCollapsedSyncPromo[] = "ntp.collapsed_sync_promo";
-#else
+// #else
 // Name of preference to count of times compose button was shown.
 inline const char kNtpComposeButtonShownCountPrefName[] =
     "ntp.compose_button.shown_count";
@@ -2507,7 +2507,7 @@ inline constexpr char kSeedColorChangeCount[] =
     "colorpicker.SeedColorChangeCount";
 // Whether the NTP footer is visible.
 inline constexpr char kNtpFooterVisible[] = "NewTabPage.FooterVisible";
-#endif  // BUILDFLAG(IS_ANDROID)
+// #endif  // BUILDFLAG(IS_ANDROID)
 
 // A private RSA key for ADB handshake.
 inline constexpr char kDevToolsAdbKey[] = "devtools.adb_key";
@@ -3226,7 +3226,7 @@ inline constexpr char kShowCastIconInToolbar[] =
     "media_router.show_cast_icon_in_toolbar";
 #endif  // !BUILDFLAG(IS_ANDROID)
 
-#if !BUILDFLAG(IS_ANDROID)
+#if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(ENABLE_DESKTOP_ANDROID_EXTENSIONS)
 // Pref name for the policy controlling the way in which users are notified of
 // the need to relaunch the browser for a pending update.
 inline constexpr char kRelaunchNotification[] = "browser.relaunch_notification";
@@ -3240,12 +3240,12 @@ inline constexpr char kRelaunchNotificationPeriod[] =
 inline constexpr char kRelaunchWindow[] = "browser.relaunch_window";
 #endif  // !BUILDFLAG(IS_ANDROID)
 
-#if !BUILDFLAG(IS_ANDROID)
+// #if !BUILDFLAG(IS_ANDROID)
 // Pref name for the policy controlling the maximum age of a build before
 // forcing a fast relaunch.
 inline constexpr char kRelaunchFastIfOutdated[] =
     "browser.relaunch_fast_if_outdated";
-#endif  // !BUILDFLAG(IS_ANDROID)
+// #endif  // !BUILDFLAG(IS_ANDROID)
 
 #if BUILDFLAG(IS_CHROMEOS)
 // Pref name for the policy controlling the time period between the first user
@@ -3388,7 +3388,7 @@ inline constexpr char kHardwareAccelerationModePrevious[] =
 // by the cloud policy subsystem.
 inline constexpr char kDevicePolicyRefreshRate[] = "policy.device_refresh_rate";
 
-#if !BUILDFLAG(IS_ANDROID)
+#if !BUILDFLAG(IS_ANDROID) || BUILDFLAG(ENABLE_DESKTOP_ANDROID_EXTENSIONS)
 // A boolean where true means that the browser has previously attempted to
 // enable autoupdate and failed, so the next out-of-date browser start should
 // not prompt the user to enable autoupdate, it should offer to reinstall Chrome
diff --git a/components/browser_ui/styles/android/BUILD.gn b/components/browser_ui/styles/android/BUILD.gn
index 56dc8e6cc8de76..125c824bd88e52 100644
--- a/components/browser_ui/styles/android/BUILD.gn
+++ b/components/browser_ui/styles/android/BUILD.gn
@@ -173,6 +173,7 @@ android_resources("java_resources") {
     "java/res/drawable/ic_drive_image_24dp.xml",
     "java/res/drawable/ic_edit_24dp.xml",
     "java/res/drawable/ic_extension_24dp.xml",
+    "java/res/drawable/ic_dev_tools_24dp.xml",
     "java/res/drawable/ic_eye_crossed.xml",
     "java/res/drawable/ic_fast_forward_white_24dp.xml",
     "java/res/drawable/ic_fast_rewind_white_24dp.xml",
diff --git a/components/browser_ui/styles/android/java/res/drawable/ic_dev_tools_24dp.xml b/components/browser_ui/styles/android/java/res/drawable/ic_dev_tools_24dp.xml
new file mode 100644
index 00000000000000..e183a4ef5f38e6
--- /dev/null
+++ b/components/browser_ui/styles/android/java/res/drawable/ic_dev_tools_24dp.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2025 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="164"
+    android:viewportHeight="143">
+    <path
+        android:fillColor="@android:color/white"
+        android:pathData="M 87.5,25.5 C 95.0001,24.1657 97.8334,27.1657 96,34.5C 87.075,60.2821 77.575,85.7821 67.5,111C 60,112.833 57.1667,110 59,102.5C 68.0268,76.5787 77.5268,50.912 87.5,25.5 Z"/>
+    <path 
+        android:fillColor="@android:color/white"
+        android:pathData="M 47.5,37.5 C 53.7915,35.9837 56.9582,38.3171 57,44.5C 49.6832,52.6508 42.1832,60.6508 34.5,68.5C 41.4854,75.9857 48.652,83.319 56,90.5C 58.0207,97.8144 55.1874,100.648 47.5,99C 38.6667,90.1667 29.8333,81.3333 21,72.5C 19,69.8333 19,67.1667 21,64.5C 30.0356,55.6317 38.869,46.6317 47.5,37.5 Z"/>
+    <path 
+        android:fillColor="@android:color/white"
+        android:pathData="M 100.5,37.5 C 103.32,37.2475 105.986,37.7475 108.5,39C 117,47.5 125.5,56 134,64.5C 136,67.1667 136,69.8333 134,72.5C 125.167,81.3333 116.333,90.1667 107.5,99C 99.8126,100.648 96.9793,97.8144 99,90.5C 106.348,83.319 113.515,75.9857 120.5,68.5C 113.515,61.0143 106.348,53.681 99,46.5C 97.0583,43.1406 97.5583,40.1406 100.5,37.5 Z"/>
+</vector>
